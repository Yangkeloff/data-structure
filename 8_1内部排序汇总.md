## 插入排序
算法思想：每次将⼀个待排序的记录按其关键字⼤⼩插⼊到前⾯已排好序的⼦序列中，直到全部记录插⼊完成。
### 直接插入排序
```
void InsertSort(int A[],int n){
  int i,j,temp;
  for (i=1; i<n; i++) {   // 将各元素加入已排序的序列中
    if (A[i]<A[i-1]) {    // 若A[i]小于其前驱
      temp=A[i];    // 暂存A[i]
      for (j=i-1; j>=0 && A[j]>temp; --j) {  // 检查i之前，即已经排好序的所有元素
        A[j+1]=A[j];      // 大于A[i]的元素后移
      }
      A[j+1]=temp;  // 跳出内部对比循环时，表示前面没有比A[i]再小的元素，将A[i]插入此位置
    }
  }
}
```
- 空间复杂度：O(1)
- 时间复杂度：主要来⾃对⽐关键字、移动元素，若有 n 个元素，则需要n-1趟处理$O(n^2)$

### 希尔排序
直接插入排序在待排序表基本有序的状态时性能最佳

希尔排序：先将待排序表分割成若⼲形如 L[i, i + d, i + 2d,…, i + kd] 的“特殊”⼦表，对各个⼦表分别进⾏直接插⼊排序。缩⼩**增量d**，重复上述过程，直到d=1时，全部排序完成。
```
void ShellSort(int A[],int n){
  int d,i,j;
  for (d=n/2; d>=1; d=d/2) {  // 步长变化
    for (i=d+1; i<=n; i=i+d) {  // 将A[i]插入有序增量子表(循环从子表的第2个元素开始，同插入排序，默认第一个元素已经有序)
      if (A[i]<A[i-d]) {   // 如果当前A[i]小于子表中的前一个元素
        A[0]=A[i];  // 暂存A[i]
        // 对子表进行插入排序中向后移动元素的操作，区别在于只处理当前子表及子表中的每个元素的前一个元素为-d而不是-1
        for (j=i-d; j>0 && A[0]<A[j]; j-=d)
          A[j+d]=A[j];  // 子表记录在子表中后移
        A[j+d]=A[0];  // 插入暂存元素
      }
    }
  }
}
```

## 基于交换的排序
根据序列中两个元素关键字的⽐较结果来对换这两个记录在序列中的位置
### 冒泡排序
从后往前（或从前往后）两两⽐较相邻元素的值，若为逆序（即A[i-1]>A[i]），则交换它们，直到序列⽐较完。称这样过程为“⼀趟”冒泡排序。
```
void BubbleSort(int A[],int n){
  int i,j;
  for (i=0; i<n-1; ++i) { // n-1趟排序
    bool flag=false;    // 本趟排序是否发生交换的标志
    for (j=n-1; j>i; --j) {   // 一趟冒泡
      if (A[j]<A[j-1]) {    // 每个元素和前一个元素对比
        swap(A[j], A[j-1]);   // 若前者大于后者，交换
        flag=true;    // 本趟发生了交换
      }
    }
    if (flag==false) return;  // 如果本趟遍历没发生交换，则说明数组已有序
  }
}
```
- 空间复杂度：O(1)
- 时间复杂度：$O(n^2)$

### 快速排序
算法思想：在待排序表L[1…n]中任取⼀个元素pivot作为枢轴（或基准，通常取⾸元素），通过⼀趟排序将待排序表划分为独⽴的两部分L[1…k-1]和L[k+1…n]，使得L[1…k-1]中的所有元素⼩于pivot，L[k+1…n]中的所有元素⼤于等于pivot，则pivot放在了其最终位置L(k)上，这个过程称为⼀次“划分”。然后分别递归地对两个⼦表重复上述过程，直⾄每部分内只有⼀个元素或空为⽌，即所有元素放在了其最终位置上。
```

int Partition(int A[],int low,int high) {
    int pivot = A[low];     // 取第一个元素作为枢轴
    while (low<high) {      // 用low、high搜索枢轴的最终位置
        // high指针不断左移，寻找到比枢轴小的元素跳出循环，或和low指针相遇时跳出循环
        while(low<high && A[high]>=pivot) --high;
        A[low]=A[high];     // 比枢轴小的元素移动到左端
        // low指针不断右移，寻找到比枢轴大的元素跳出循环，或和high指针相遇时跳出循环
        // 先high指针左移,再low指针右移，顺序不能反
        while(low<high && A[low]<=pivot) ++low;
        A[high]=A[low];     // 比枢轴大的元素移动到右端
    }
    A[low] = pivot;     // 循环结束(low和high相遇)时，low=high，即枢轴的最终位置
    return low;     // 返回本次枢轴存放的位置
}

void QuickSort(int A[],int low,int high) {
    if (low<high) {     // 跳出递归条件
        int pivotPos = Partition(A,low,high);   // 获取上一次排序枢轴的最终位置，划分左右子表，递归
        QuickSort(A, low, pivotPos-1);   // 左子表，以初始low(一般为0)为最左，上一次的枢轴-1为最右，进行下一次排序
        QuickSort(A, pivotPos+1, high);  // 右子表，以上一次的枢轴+1为最左，初始high为最右(一般为表尾)，进行下一次排序
    }
}
```
- 时间复杂度: $O(nlog_2n)$
- **不稳定**
  
## 选择排序
每⼀趟在待排序元素中选取关键字最⼩（或最⼤）的元素加⼊有序⼦序列
### 简单选择排序
```
void SelectSort(int A[],int n){
  int i,j;
  for (i=0; i<n-1; ++i) {   // 检查0～n-1号元素
    int min=i;    // 记录最小元素位置
    for (j=i+1; j<n; ++j) {   // 检查当前最小元素位置i之后的元素A[i]~A[n-1]
      if (A[j]<A[min]) min=j;   // 发现比初始最小元素更小的，更新最小元素位置
    }
    if (min!=i) swap(A[i], A[min]);   // 最小元素位置发生变化，调整元素(swap函数会移动元素3次)
  }
}
```
- 空间复杂度：O(1)
- 时间复杂度：$O(n^2)$
- **不稳定**
- 顺序表、链表都适用

### 堆排序
思路：把所有⾮终端结点都检查⼀遍，是否满⾜⼤根堆的要求，如果不满⾜，则进⾏调整（⼤根堆：根≥左、右）  

每一趟将堆顶元素(即待排序元素中最大的)加入有序子序列（与堆底元素，即待排序序列中的最后一个元素交换）并将**待排序元素序列**再次调整为大根堆（小元素不断“下坠 ”）,使待排序元素中最大的成为堆顶元素

```
// 建立大根堆（大根堆：完全二叉树中，根结点值大于等于左右孩子）
void BuildMaxHeap(int A[],int len){
    for (int i=len/2; i>0; i--) {   // 从后向前遍历所有非终端结点(i<=n/2向下取整)，进行调整
        HeadAdjust(A,i,len);
    }
} 
// 将以k为根的子树调整为大根堆
void HeadAdjust(int A[],int k,int len){
    A[0]=A[k];      // 暂存要调整结点的值
    for (int i=2*k; i<=len; i*=2) {     // 2k即当前结点k的左孩子，沿较大的子结点向下筛选，如果i>len则说明没有左右孩子
        if (i<len && A[i]<A[i+1])   // i=2k为左孩子,i+1即为右孩子,i<len则无右兄弟
            i++;    // 对比两者，若右孩子更大则i++,指向右孩子
        
        if (A[0]>=A[i]) break;   // 判断k结点是否大于等于其左右孩子，如果是，满足根结点值大于等于左右孩子，则跳出本轮循环
        else {      // 当前根结点k不满足大根堆（根大于等于左、右），小元素不断“下坠”的处理
            A[k]=A[i];  // 将左右孩子中更大的移动到根结点位置
            k=i;    // 将k下移，继续进行下一轮与左右孩子的对比
        }
    }
    A[k]=A[0];  // 被筛选结点的值放入最终位置
}
// 堆排序：每一趟将堆顶元素加入有序子序列（与堆底元素，即待排序序列中的最后一个元素交换）
void HeapSort(int A[],int len){
    BuildMaxHeap(A, len);
    for (int i=len; i>0; i--) {   // n-1趟交换和整理堆的过程
        Swap(A[1], A[i]);   // 堆顶和堆底元素交换
        HeadAdjust(A, 1, i-1);  // 交换后，剩余元素整理成大根堆，即把刚刚交换到堆顶的元素进行“下坠”；i此时已经处于最终位置，所以只需处理i前面的元素（i-1）
    }
}
```
- 空间复杂度：O(1)
- 时间复杂度：$O(nlog_2n)$

## 归并排序
归并：把两个或多个已经有序的序列合并成⼀个
```
int *B = (int*)malloc((n+1)*sizeof(int)); // 辅助数组B

void Merge(int A[],int low,int mid,int high){
  int k,i,j;
  for (k=low; k<=high; k++) { // 复制A中所有元素到B
    B[k]=A[k];
  }
  // 对⽐ i、j 所指元素，选择更⼩的⼀个放⼊ k 所指位置
  for (i=low,j=mid+1,k=i; i<=mid && j<=high; k++) { // 比较B左右两段的元素，较小者放入A
    if (B[i]<=B[j])
      A[k]=B[i++];
    else
      A[k]=B[j++];
  }
  while (i<=mid) A[k++]=B[i++]; // 若B前半段还有剩余，依次加入A
  while (j<=high) A[k++]=B[j++];  // 若B后半段还有剩余，依次加入A
}

void MergeSort(int A[],int low,int high) {
  if (low<high) {
    int mid = (low+high)/2; // 划分为两个子序列
    MergeSort(A, low, mid); // 递归左侧
    MergeSort(A, mid+1, high);  // 递归右侧
    Merge(A, low, mid, high); // 合并左右
  }
}
```
- 空间复杂度：O(n)，来自于辅助数组B
- 时间复杂度：$O(nlog_2n)$